package biz.lobachev.annette.data_dictionary.builder.rendering.click_house_ddl

import biz.lobachev.annette.data_dictionary.builder.CLICKHOUSE
import biz.lobachev.annette.data_dictionary.builder.labels._
import biz.lobachev.annette.data_dictionary.builder.labels.OverrideDatatype.CLICKHOUSE_DATA_TYPE
import biz.lobachev.annette.data_dictionary.builder.model._
import biz.lobachev.annette.data_dictionary.builder.rendering.{RenderResult, TextRenderer}
import biz.lobachev.annette.data_dictionary.builder.utils.StringSyntax._

import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter

case class ClickHouseDDLRenderer(
  domain: Domain,
  filename: String = "click_house_ddl.sql",
) extends TextRenderer {

  def header = {
    val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
    val date      = OffsetDateTime.now().toLocalDateTime.format(formatter)
    Seq(
      s"-- ${domain.name}",
      "-- Code generated by Data Dictionary Builder (c) Valery Lobachev (https://github.com/valerylobachev/data-dictionary-builder).",
      s"-- Date: $date",
    )
  }

  override def render(): Seq[RenderResult] = {
    val res    = domain.rootComponentIds.map(id => renderComponent(id))
    val tables = res
      .map(_.tables)
      .filter(s => !s.trim.isBlank)
      .mkString("\n", "\n", "\n")

    Seq(
      Some(
        RenderResult(
          s"",
          filename,
          (
            header ++ Seq(
              tables,
            )
          ).mkString("\n"),
        ),
      ),
    ).flatten
  }

  private def renderComponent(id: String): DDLSegments = {
    val res1      = domain.entities.values
      .filter(e => e.entityType == TableEntity && e.componentId == id)
      .map(entity => renderEntity(entity))
    val component = domain.components(id)
    val res2      = component.children.map(id => renderComponent(id))
    DDLSegments(
      tables = (res1 ++ res2)
        .map(_.tables)
        .filter(_.nonEmpty)
        .mkString("\n"),
    )
  }

  private def renderEntity(entity: Entity): DDLSegments =
    DDLSegments(
      tables = renderTable(entity),
    )

  private def renderTable(entity: Entity): String =
    if (
      entity.labels
        .get(ClickHouse.CLICKHOUSE_ENGINE)
        .map(e => e != ClickHouse.CLICKHOUSE_ENGINE_EXCLUDE)
        .getOrElse(true)
    ) {
      val fields = entity.expandedFields.map { field =>
        val fieldName = wrapQuotes(field.dbFieldName)
        val datatype  =
          field.labels.get(CLICKHOUSE_DATA_TYPE).getOrElse(domain.getTargetDataType(field.dataType, CLICKHOUSE))
        val notNull   = if (field.notNull) " NOT NULL" else ""
        val comment   = if (!field.name.trim.isBlank()) {
          s" COMMENT '${field.name}'"
        } else ""
        s"  $fieldName $datatype$notNull$comment"
      }.mkString(",\n")

      val primaryKey = if (entity.pk.nonEmpty) {
        val pkFields = entity.pk.map(f => getEntityFieldName(entity.expandedFields, f)).mkString("(", ", ", ")")
        s"\n  PRIMARY KEY $pkFields"
      } else ""

      val tableComment = if (!entity.name.trim.isBlank()) {
        s"\n  COMMENT '${entity.name}'"
      } else ""

      val engine = entity.labels.get(ClickHouse.CLICKHOUSE_ENGINE).getOrElse("MergeTree()")

      Seq(
        s"CREATE TABLE ${entity.tableNameWithSchema()} (",
        fields,
        ")\n" +
          s"  ENGINE = $engine" +
          s"$primaryKey$tableComment;\n",
      ).mkString("\n")
    } else ""

  def getEntityFieldName(entityFields: Seq[EntityField], fieldName: String): String =
    entityFields
      .find(f => f.fieldName == fieldName)
      .map(f => wrapQuotes(f.dbFieldName))
      .getOrElse {
        throw new IllegalArgumentException(s"not found field $fieldName")
      }

}
